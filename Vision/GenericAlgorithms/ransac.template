#include <limits>
#include <stdlib.h>
#include <boost/foreach.hpp>

namespace RANSAC
{
//    vector<LSFittedLine> findMultipleLines(const vector<Point>& line_points, double e, unsigned int n, unsigned int k, unsigned int max_iterations)
//    {
//        double variance;
//        bool line_found;
//        Line line;
//        LSFittedLine fitted_line;
//        vector<LSFittedLine> results;
//        vector<Point> consensus;
//        vector<Point> remainder;

//        //run first iterations

//        line_found = findLine(line_points, line, consensus, remainder, variance, e, n, k);

//        unsigned int i=0;
//        while(line_found && i<max_iterations) {
//            fitted_line.clearPoints();
//            fitted_line.addPoints(consensus);
//            results.push_back(fitted_line);
//            line_found = findLine(remainder, line, consensus, remainder, variance, e, n, k);
//            i++;
//        }

//        return results;
//    }

//    //        bool findLineFit(std::vector<Point> points, Line& result, std::vector<Point>& consensus, std::vector<Point>& remainder, double& variance, double e, unsigned int n, unsigned int k)
//    //        {
//    //            if (points.size() < n) {
//    //                return false;
//    //            }

//    //            // error of best line found so far
//    //            double minerr = std::numeric_limits<double>::max();
//    //            // arrays for storing concensus sets
//    //            bool c1[points.size()];
//    //            bool c2[points.size()];

//    //            bool* best_concensus;
//    //            bool* cur_concensus;
//    //            best_concensus = c1;
//    //            consensus.clear();

//    //            for (unsigned int i = 0; i < k; ++i) {
//    //              // randomly select 2 distinct points
//    //                Line l = generateRandomLine(points);
//    //                variance = 0;
//    //                // figure out the variance (sum of distances of points from the line)
//    //                // could use dist() here, but since the denominator is consistent, we
//    //                // save time and implement it again here.
//    //        //      double denom = l.getNormaliser();
//    //        //      double newe = m_e*denom;
//    //                double newe = e*l.getNormaliser();
//    //                unsigned int concensus_size = 0;

//    //                if (c1 == best_concensus)
//    //                   cur_concensus = c2;
//    //                else
//    //                   cur_concensus = c1;

//    //                for (unsigned int i = 0; i < points.size(); i++) {
//    //                    double dist = l.getLinePointDistance(points.at(i));
//    //                    if (dist < newe) {
//    //                        variance += dist;
//    //                        concensus_size++;
//    //                        cur_concensus[i] = true;
//    //                    }
//    //                    else {
//    //                        cur_concensus[i] = false;
//    //                    }
//    //                }
//    //        //      variance /= denom;
//    //                static double scaling_factor = 0.2;
//    //                variance = scaling_factor*variance - concensus_size;
//    //                if (variance < minerr && concensus_size >= n) {
//    //                    minerr = variance;
//    //                    result = l;
//    //                    best_concensus = cur_concensus;
//    //                }
//    //            }
//    //            variance = variance/(points.size()*e);

//    //            consensus.clear();
//    //            remainder.clear();

//    //            if (minerr < std::numeric_limits<double>::max()) {
//    //                for(unsigned int i=0; i<points.size(); i++) {
//    //                    if(best_concensus[i])
//    //                        consensus.push_back(points.at(i));
//    //                    else {
//    //                        remainder.push_back(points.at(i));
//    //                    }
//    //                }
//    //                return true;
//    //            }
//    //            else {
//    //                return false;
//    //            }
//    //        }

//    bool findLine(vector<Point> points, Line& result, std::vector<Point>& consensus, std::vector<Point>& remainder, double& variance, double e, unsigned int n, unsigned int k)
//    {
//        if (points.size() < n || n<2) {
//            return false;
//        }

//        double minerr = std::numeric_limits<double>::max();
//        // arrays for storing concensus sets
//        bool c1[points.size()];
//        bool c2[points.size()];

//        bool* best_concensus;
//        bool* cur_concensus;
//        best_concensus = c1;
//        double cur_variance;
//        bool line_found = false;

//        for (unsigned int i = 0; i < k; ++i) {
//            // randomly select 2 distinct points
//            Line l = generateRandomLine(points);
//            cur_variance = 0;

//            unsigned int concensus_size = 0;

//            cur_concensus = (c1 == best_concensus ? c2 : c1);   //use the concensus that is not currently the best

//            //determine consensus set
//            for (unsigned int i = 0; i < points.size(); i++) {
//                double dist = l.getLinePointDistance(points.at(i));
//                if (dist < e) {
//                    cur_variance += dist;
//                    concensus_size++;
//                    cur_concensus[i] = true;
//                }
//                else {
//                    cur_concensus[i] = false;
//                }
//            }

//            cur_variance /= concensus_size; //normalise the variance

//            if(concensus_size >= n && cur_variance < minerr) {
//                line_found = true;
//                result = l;
//                minerr = cur_variance;
//                best_concensus = cur_concensus;
//            }
//        }
//        //variance = variance/(points.size()*e);
//        variance = minerr;

//        consensus.clear();
//        remainder.clear();

//        if (line_found) {
//            for(unsigned int i=0; i<points.size(); i++) {
//                if(best_concensus[i])
//                    consensus.push_back(points.at(i));
//                else {
//                    remainder.push_back(points.at(i));
//                }
//            }
//            return true;
//        }
//        else {
//            return false;
//        }
//    }

//    Line generateRandomLine(const vector<Point>& points)
//    {
//        if(points.size() > 1) {
//            Point p1, p2;
//            p1 = points.at(rand() % points.size());
//            do {
//                p2 = points.at(rand() % points.size());
//            }
//            while (p1 == p2);
//            return Line(p1, p2);
//        }
//        else {
//            return Line();
//        }
//    }

    template<class Model, typename DataPoint>
    vector<pair<Model, vector<DataPoint> > > findMultipleModels(const vector<DataPoint>& points, double e, unsigned int n, unsigned int k, unsigned int max_iterations, RANSAC::SELECTION_METHOD method)
    {
        double variance;
        bool found;
        Model model;
        vector<pair<Model, vector<DataPoint> > > results;
        vector<DataPoint> consensus;
        vector<DataPoint> remainder;

        //run first iterations

        found = findModel(points, model, consensus, remainder, variance, e, n, k, method);

        unsigned int i=0;
        while(found && i<max_iterations) {
            results.push_back(pair<Model, vector<DataPoint> >(model, consensus));
            found = findModel(remainder, model, consensus, remainder, variance, e, n, k, method);
            i++;
        }

        return results;
    }

    template<class Model, typename DataPoint>
    bool findModel(vector<DataPoint> points, Model &result, vector<DataPoint>& consensus, vector<DataPoint>& remainder, double& variance, double e, unsigned int n, unsigned int k, RANSAC::SELECTION_METHOD method)
    {
        if (points.size() < n || n<result.minPointsForFit()) {
            return false;
        }

        double minerr = std::numeric_limits<double>::max(); // Used for BestFittingConsensus method
        size_t largestconsensus = 0;                        // Used for LargestConsensus method
        // arrays for storing concensus sets
        bool c1[points.size()];
        bool c2[points.size()];

        bool* best_concensus;
        bool* cur_concensus;
        best_concensus = c1;
        double cur_variance;
        bool found = false;

        for (unsigned int i = 0; i < k; ++i) {
            // randomly select 2 distinct points
            Model m = generateRandomModel<Model, DataPoint>(points);
            cur_variance = 0;

            unsigned int concensus_size = 0;

            cur_concensus = (c1 == best_concensus ? c2 : c1);   //use the concensus that is not currently the best

            //determine consensus set
            for (unsigned int i = 0; i < points.size(); i++) {
                double dist = m.calculateError(points.at(i));
                if (dist < e) {
                    cur_variance += dist;
                    concensus_size++;
                    cur_concensus[i] = true;
                }
                else {
                    cur_concensus[i] = false;
                }
            }

            cur_variance /= concensus_size; //normalise the variance

            //determine whether the consensus is better
            if(concensus_size >= n) {
                switch(method) {
                case LargestConsensus:
                    if(concensus_size > largestconsensus) {
                        found = true;
                        result = m;
                        largestconsensus = concensus_size;
                        minerr = cur_variance;  //keep variance for other purposes
                        best_concensus = cur_concensus;
                    }
                    break;
                case BestFittingConsensus:
                    if(cur_variance < minerr) {
                        found = true;
                        result = m;
                        minerr = cur_variance;
                        best_concensus = cur_concensus;
                    }
                    break;
                }

            }
        }
        //variance = variance/(points.size()*e);
        variance = minerr;

        if(found) {
            consensus.clear();
            remainder.clear();

            for(unsigned int i=0; i<points.size(); i++) {
                if(best_concensus[i])
                    consensus.push_back(points.at(i));
                else
                    remainder.push_back(points.at(i));
            }
        }
        return found;
    }

    //NOTE: Assumes that there are no duplicates in the data
    //      point set (only way to guarantee no infinite loop)
    template<class Model, typename DataPoint>
    Model generateRandomModel(const vector<DataPoint>& points)
    {
        Model model;
        size_t n = points.size();
        if(n >= model.minPointsForFit()) {
            vector<size_t> indices;
            size_t next;
            indices.push_back(rand() % n);

            while(indices.size() < model.minPointsForFit()) {
                bool unique;
                do {
                    unique = true;
                    next = rand() % n;
                    BOOST_FOREACH(size_t i, indices) {
                        if(i == next)
                            unique = false;
                    }
                }
                while(!unique);
                indices.push_back(next);
            }

            vector<DataPoint> rand_pts;
            BOOST_FOREACH(size_t i, indices) {
                rand_pts.push_back(points.at(i));
            }

            model.regenerate(rand_pts);
        }
        return model;
//        Model model;
//        if(points.size() >= model.minPointsForFit()) {
//            vector<DataPoint> rand_pts;
//            DataPoint next;
//            rand_pts.push_back(points.at(rand() % points.size()));

//            while(rand_pts.size() < model.minPointsForFit()) {
//                bool unique;
//                do {
//                    unique = true;
//                    next = points.at(rand() % points.size());
//                    BOOST_FOREACH(DataPoint& pt, rand_pts) {
//                        if(pt == next)
//                            unique = false;
//                    }
//                }
//                while(!unique);
//                rand_pts.push_back(next);
//            }
//            model.regenerate(rand_pts);
//        }
//        return model;
    }
}


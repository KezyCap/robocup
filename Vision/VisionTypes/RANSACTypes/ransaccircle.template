#include <cmath>

template<typename T>
RANSACCircle<T>::RANSACCircle()
{
}

template<typename T>
bool RANSACCircle<T>::regenerate(const vector<T>& pts)
{
    if(pts.size() == 3) {
        return constructFromPoints(pts[0], pts[1], pts[2], 1.0e-2);
    }
    else {
        return false;
    }
}

template<typename T>
double RANSACCircle<T>::calculateError(T p) const
{
    return std::abs( (p.screen - m_centre.screen).abs() - m_radius);
}

template<typename T>
bool RANSACCircle<T>::constructFromPoints(T p1, T p2, T p3, double tolerance)
{
    T ab = p1 - p2,
      bc = p2 - p3;
    double det = ab.x*bc.y-bc.x*ab.y;

    if (std::abs(det) < tolerance) {
        return false;
    }

    double b_len_sqr = p2.squareAbs();

    double ab_norm = (p1.squareAbs() - b_len_sqr)/2.0;
    double bc_norm = (b_len_sqr - p3.squareAbs())/2.0;

    det = 1/det;
    m_centre.x = (ab_norm*(bc.y)-bc_norm*(ab.y))*det;
    m_centre.y = ((ab.x)*bc_norm-(bc.x)*ab_norm)*det;

    m_radius = (m_centre - p1).abs();
    return true;
}

bool RANSACCircle<GroundPoint>::regenerate(const vector<GroundPoint>& pts)
{
    if(pts.size() == 3) {
        return constructFromPoints(pts[0].ground, pts[1].ground, pts[2].ground, 1.0e-2);
    }
    else {
        return false;
    }
}

double RANSACCircle<GroundPoint>::calculateError(GroundPoint p) const
{
    return std::abs( (p.ground - m_centre.ground).abs() - m_radius);
}
